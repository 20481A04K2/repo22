steps:
  # ==========================================
  # Step 1: Wait logic for running triggers and MIG VM readiness
  # ==========================================
  - name: gcr.io/google.com/cloudsdktool/cloud-sdk
    entrypoint: bash
    args:
      - -c
      - |
        echo "‚è≥ Checking ongoing triggers and MIG VM readiness..."

        WATCHED_TRIGGERS=("trigger-2" "trigger-3")
        CURRENT_TRIGGER="$${_TRIGGER_NAME:-trigger-1}"
        MIG_NAME="vamsi-mig"
        ZONE="asia-east1-b"

        echo "‚ÑπÔ∏è Current Trigger: $$CURRENT_TRIGGER"

        # Get current build info for this trigger
        CURRENT_BUILD_INFO=$$(gcloud builds list --region=asia-east1 \
          --filter="status:(WORKING OR QUEUED) AND substitutions.TRIGGER_NAME=$$CURRENT_TRIGGER" \
          --sort-by="~createTime" --limit=1 --format="value(id,createTime)")

        if [[ -z "$$CURRENT_BUILD_INFO" ]]; then
          echo "‚ö†Ô∏è No ongoing build found for $$CURRENT_TRIGGER."
          exit 0
        fi

        CURRENT_BUILD_ID=$$(echo "$$CURRENT_BUILD_INFO" | awk '{print $$1}')
        CURRENT_START_TIME=$$(echo "$$CURRENT_BUILD_INFO" | awk '{print $$2}')

        echo "‚è∞ Current build $$CURRENT_BUILD_ID started at: $$CURRENT_START_TIME"
        # Initialize trigger-info.txt with current trigger info only
        echo "$$CURRENT_TRIGGER|$$CURRENT_START_TIME" > /workspace/trigger-info.txt
        # Function to wait for a build to finish
        wait_for_build() {
          local TRIGGER_NAME=$$1
          local BUILD_ID=$$2
          while true; do
            STATUS=$$(gcloud builds describe $$BUILD_ID --region=asia-east1 --format="value(status)")
            if [[ "$$STATUS" == "SUCCESS" || "$$STATUS" == "FAILURE" || "$$STATUS" == "CANCELLED" ]]; then
              echo "üîπ $$TRIGGER_NAME build $$BUILD_ID finished with $$STATUS"
              break
            fi
            echo "‚è± $$TRIGGER_NAME build $$BUILD_ID still running, waiting 15s..."
            sleep 15
          done
          if [[ "$$STATUS" == "SUCCESS" ]]; then
            echo "‚úÖ $$TRIGGER_NAME succeeded. Waiting 90 seconds..."
            sleep 90
          else
            echo "‚ö†Ô∏è $$TRIGGER_NAME failed/cancelled. Waiting 30 seconds..."
            sleep 30
          fi
        }

        # Loop to check ongoing triggers
        while true; do
          PREV_RUNNING=0
          PREV_TRIGGER_NAME=""
          PREV_BUILD_ID=""

          for TRIGGER in "$${WATCHED_TRIGGERS[@]}"; do
            if [[ "$$TRIGGER" == "$$CURRENT_TRIGGER" ]]; then
              continue
            fi

            BUILD_INFO=$$(gcloud builds list --region=asia-east1 \
              --filter="status:(WORKING OR QUEUED) AND substitutions.TRIGGER_NAME=$$TRIGGER" \
              --sort-by="~createTime" --limit=1 --format="value(id,createTime)")

            if [[ -n "$$BUILD_INFO" ]]; then
              BUILD_START=$$(echo "$$BUILD_INFO" | awk '{print $$2}')
              if [[ "$$BUILD_START" < "$$CURRENT_START_TIME" ]]; then
                PREV_RUNNING=$$((PREV_RUNNING+1))
                PREV_TRIGGER_NAME="$$TRIGGER"
                PREV_BUILD_ID=$$(echo "$$BUILD_INFO" | awk '{print $$1}')
              fi
            fi
          done

          if [[ $$PREV_RUNNING -eq 0 ]]; then
            echo "‚úÖ No previous triggers running ‚Üí skip wait and go to Step 2."
            break
          elif [[ $$PREV_RUNNING -eq 1 ]]; then
            echo "‚è≥ One previous trigger ($$PREV_TRIGGER_NAME) is running ‚Üí wait for MIG rolling update to start..."

            # ‚úÖ NEW LOGIC: Wait until MIG rolling update actually starts
            while true; do
              CURRENT_ACTIONS=$$(gcloud compute instance-groups managed list-instances $$MIG_NAME \
                --zone=$$ZONE --format="value(currentAction)" | grep -v NONE || true)

              if [[ -n "$$CURRENT_ACTIONS" ]]; then
                echo "üîÑ MIG rolling update detected, fetching latest template..."
                break
              fi

              echo "‚è± Waiting for MIG rolling update to start..."
              sleep 15
            done

            # Once rolling update started, get latest template being rolled out
            LATEST_TEMPLATE=$$(gcloud compute instance-groups managed list-instances $$MIG_NAME \
              --zone=$$ZONE \
              --format="value(version.instanceTemplate.basename())" | sort | uniq | tail -n 1)

            echo "‚ÑπÔ∏è Latest template being deployed: $$LATEST_TEMPLATE"

            # Wait for at least one VM from this template to be healthy
            while true; do
              READY_VM=$$(gcloud compute instance-groups managed list-instances $$MIG_NAME \
                  --zone=$$ZONE \
                  --format="value(name,version.instanceTemplate.basename(),currentAction,healthState)" \
                  | awk -v tmpl="$$LATEST_TEMPLATE" '$$2==tmpl && $$3=="NONE"  {print $$1}' \
                  | head -n1)

              if [[ -n "$$READY_VM" ]]; then
                echo "‚úÖ MIG VM $$READY_VM from rolling update template $$LATEST_TEMPLATE is healthy."

                echo "‚è≥ Now waiting for previous trigger ($$PREV_TRIGGER_NAME) build $$PREV_BUILD_ID to complete..."
                wait_for_build "$$PREV_TRIGGER_NAME" "$$PREV_BUILD_ID"

                echo "‚úÖ Previous trigger ($$PREV_TRIGGER_NAME) completed ‚Üí proceed to Step 2."
                break 2
              fi
              echo "‚è± Waiting for MIG VM from template ($$LATEST_TEMPLATE) to be ready..."
              sleep 15
            done
          else
            echo "‚ö†Ô∏è Found multiple previous triggers running ($$PREV_RUNNING) ‚Üí executing wait logic..."
            wait_for_build "$$PREV_TRIGGER_NAME" "$$PREV_BUILD_ID"
            # After waiting, loop will re-evaluate PREV_RUNNING
          fi
        done
  # ==========================================
  # Step 1: Generate version tag
  # ==========================================
  - name: gcr.io/cloud-builders/gcloud
    id: generate-version
    entrypoint: bash
    args:
      - -c
      - |
        VERSION_TAG="v-$(date +%Y%m%d-%H%M%S)"
        echo "VERSION_TAG=$$VERSION_TAG" > /workspace/version.env
        echo "Generated version: $$VERSION_TAG"

  # ==========================================
  # Step 2: Clone GitHub repo
  # ==========================================
  - name: gcr.io/cloud-builders/git
    id: clone-repo
    args:
      - clone
      - https://github.com/${_GITHUB_REPO}.git
      - /workspace/app

  # ==========================================
  # Step 3: Build the specified API and create ZIP
  # ==========================================
  - name: 'python:3.11'
    id: build-api
    entrypoint: bash
    args:
      - -c
      - |
        apt-get update && apt-get install -y zip
        source /workspace/version.env
        cd /workspace/app/${_API_NAME}

        echo "[BUILD] Processing ${_API_NAME}..."

        # Create ZIP of API folder
        zip -r "/workspace/${_API_NAME}-$${VERSION_TAG}.zip" *

  # ==========================================
  # Step 4: Upload API ZIP to GCS
  # ==========================================
  - name: gcr.io/cloud-builders/gsutil
    id: upload-zip
    entrypoint: bash
    args:
      - -c
      - |
        source /workspace/version.env
        echo "[GCS] Uploading ${_API_NAME} ZIP..."
        gsutil cp "/workspace/${_API_NAME}-$${VERSION_TAG}.zip" gs://$_GCS_BUCKET/${_API_NAME}/$${VERSION_TAG}.zip
        echo "[GCS] Uploaded /workspace/${_API_NAME}-$${VERSION_TAG}.zip to gs://$_GCS_BUCKET/${_API_NAME}/"

  # ==========================================
  # Step 5: Update api_state.json in GCS
  # ==========================================
  - name: gcr.io/cloud-builders/gsutil
    id: update-json
    entrypoint: bash
    args:
      - -c
      - |
        # Install jq
        apt-get update && apt-get install -y jq

        # Load version tag
        source /workspace/version.env

        TMP_JSON=/workspace/api_state.json

        # Fetch existing JSON from GCS or create empty
        if ! gsutil cp gs://$_GCS_BUCKET/api_state.json $TMP_JSON 2>/dev/null; then
          echo "{}" > $TMP_JSON
        fi

        echo "Version tag: $$VERSION_TAG"
        echo "Workspace content:"
        ls -l /workspace/

        # Update JSON for the built API only
        if [ -f "/workspace/${_API_NAME}-$VERSION_TAG.zip" ]; then
          echo "Updating ${_API_NAME} with version $VERSION_TAG"
          jq --arg api "${_API_NAME}" --arg version "$VERSION_TAG" '.[$api]=$version' $TMP_JSON > tmp.json
          mv tmp.json $TMP_JSON
        else
          echo "No ZIP found for ${_API_NAME}, skipping.. $TMP_JSON."
        fi

        # Upload updated JSON back to GCS
        gsutil cp $TMP_JSON gs://$_GCS_BUCKET/api_state.json
        echo "[GCS] Updated api_state.json with latest API versions"

  # ==========================================
  # Step 6: Display JSON content for verification
  # ==========================================
  - name: gcr.io/cloud-builders/gsutil
    id: show-json
    entrypoint: bash
    args:
      - -c
      - |
        echo "Current api_state.json content:"
        gsutil cp gs://$_GCS_BUCKET/api_state.json /workspace/api_state.json
        cat /workspace/api_state.json || echo "JSON is empty"


timeout: 3600s
options:
  logging: CLOUD_LOGGING_ONLY
substitutions:
  _GITHUB_REPO: "20481A04K2/repo22"
  _TRIGGER_NAME: "trigger-1"
  _GCS_BUCKET: "inosuke-wasi-wasi"
  _API_NAME: "api2"  

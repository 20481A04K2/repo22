steps:
  # ==========================================
  # Step 1: Wait logic for running triggers and MIG VM readiness
  # ==========================================
  - name: gcr.io/google.com/cloudsdktool/cloud-sdk
    entrypoint: bash
    args:
      - -c
      - |
        echo "‚è≥ Checking ongoing triggers and MIG VM readiness..."

        WATCHED_TRIGGERS=("trigger-2" "trigger-3")
        CURRENT_TRIGGER="$${_TRIGGER_NAME:-trigger-1}"
        MIG_NAME="vamsi-mig"
        ZONE="asia-east1-b"

        echo "‚ÑπÔ∏è Current Trigger: $$CURRENT_TRIGGER"

        # Get current build info for this trigger
        CURRENT_BUILD_INFO=$$(gcloud builds list --region=asia-east1 \
          --filter="status:(WORKING OR QUEUED) AND substitutions.TRIGGER_NAME=$$CURRENT_TRIGGER" \
          --sort-by="~createTime" --limit=1 --format="value(id,createTime)")

        if [[ -z "$$CURRENT_BUILD_INFO" ]]; then
          echo "‚ö†Ô∏è No ongoing build found for $$CURRENT_TRIGGER."
          exit 0
        fi

        CURRENT_BUILD_ID=$$(echo "$$CURRENT_BUILD_INFO" | awk '{print $$1}')
        CURRENT_START_TIME=$$(echo "$$CURRENT_BUILD_INFO" | awk '{print $$2}')

        echo "‚è∞ Current build $$CURRENT_BUILD_ID started at: $$CURRENT_START_TIME"
        # Initialize trigger-info.txt with current trigger info only
        echo "$$CURRENT_TRIGGER|$$CURRENT_START_TIME" > /workspace/trigger-info.txt
        # Function to wait for a build to finish
        wait_for_build() {
          local TRIGGER_NAME=$$1
          local BUILD_ID=$$2
          while true; do
            STATUS=$$(gcloud builds describe $$BUILD_ID --region=asia-east1 --format="value(status)")
            if [[ "$$STATUS" == "SUCCESS" || "$$STATUS" == "FAILURE" || "$$STATUS" == "CANCELLED" ]]; then
              echo "üîπ $$TRIGGER_NAME build $$BUILD_ID finished with $$STATUS"
              break
            fi
            echo "‚è± $$TRIGGER_NAME build $$BUILD_ID still running, waiting 15s..."
            sleep 15
          done
          if [[ "$$STATUS" == "SUCCESS" ]]; then
            echo "‚úÖ $$TRIGGER_NAME succeeded. Waiting 90 seconds..."
            sleep 90
          else
            echo "‚ö†Ô∏è $$TRIGGER_NAME failed/cancelled. Waiting 30 seconds..."
            sleep 30
          fi
        }

        # Loop to check ongoing triggers
        while true; do
          PREV_RUNNING=0
          PREV_TRIGGER_NAME=""
          PREV_BUILD_ID=""

          for TRIGGER in "$${WATCHED_TRIGGERS[@]}"; do
            if [[ "$$TRIGGER" == "$$CURRENT_TRIGGER" ]]; then
              continue
            fi

            BUILD_INFO=$$(gcloud builds list --region=asia-east1 \
              --filter="status:(WORKING OR QUEUED) AND substitutions.TRIGGER_NAME=$$TRIGGER" \
              --sort-by="~createTime" --limit=1 --format="value(id,createTime)")

            if [[ -n "$$BUILD_INFO" ]]; then
              BUILD_START=$$(echo "$$BUILD_INFO" | awk '{print $$2}')
              if [[ "$$BUILD_START" < "$$CURRENT_START_TIME" ]]; then
                PREV_RUNNING=$$((PREV_RUNNING+1))
                PREV_TRIGGER_NAME="$$TRIGGER"
                PREV_BUILD_ID=$$(echo "$$BUILD_INFO" | awk '{print $$1}')
              fi
            fi
          done

          if [[ $$PREV_RUNNING -eq 0 ]]; then
            echo "‚úÖ No previous triggers running ‚Üí skip wait and go to Step 2."
            break
          elif [[ $$PREV_RUNNING -eq 1 ]]; then
            echo "‚è≥ One previous trigger ($$PREV_TRIGGER_NAME) is running ‚Üí wait for MIG rolling update to start..."

            # ‚úÖ NEW LOGIC: Wait until MIG rolling update actually starts
            while true; do
              CURRENT_ACTIONS=$$(gcloud compute instance-groups managed list-instances $$MIG_NAME \
                --zone=$$ZONE --format="value(currentAction)" | grep -v NONE || true)

              if [[ -n "$$CURRENT_ACTIONS" ]]; then
                echo "üîÑ MIG rolling update detected, fetching latest template..."
                break
              fi

              echo "‚è± Waiting for MIG rolling update to start..."
              sleep 15
            done

            # Once rolling update started, get latest template being rolled out
            LATEST_TEMPLATE=$$(gcloud compute instance-groups managed list-instances $$MIG_NAME \
              --zone=$$ZONE \
              --format="value(version.instanceTemplate.basename())" | sort | uniq | tail -n 1)

            echo "‚ÑπÔ∏è Latest template being deployed: $$LATEST_TEMPLATE"

            # Wait for at least one VM from this template to be healthy
            while true; do
              READY_VM=$$(gcloud compute instance-groups managed list-instances $$MIG_NAME \
                  --zone=$$ZONE \
                  --format="value(name,version.instanceTemplate.basename(),currentAction,healthState)" \
                  | awk -v tmpl="$$LATEST_TEMPLATE" '$$2==tmpl && $$3=="NONE"  {print $$1}' \
                  | head -n1)

              if [[ -n "$$READY_VM" ]]; then
                echo "‚úÖ MIG VM $$READY_VM from rolling update template $$LATEST_TEMPLATE is healthy."

                echo "‚è≥ Now waiting for previous trigger ($$PREV_TRIGGER_NAME) build $$PREV_BUILD_ID to complete..."
                wait_for_build "$$PREV_TRIGGER_NAME" "$$PREV_BUILD_ID"

                echo "‚úÖ Previous trigger ($$PREV_TRIGGER_NAME) completed ‚Üí proceed to Step 2."
                break 2
              fi
              echo "‚è± Waiting for MIG VM from template ($$LATEST_TEMPLATE) to be ready..."
              sleep 15
            done
          else
            echo "‚ö†Ô∏è Found multiple previous triggers running ($$PREV_RUNNING) ‚Üí executing wait logic..."
            wait_for_build "$$PREV_TRIGGER_NAME" "$$PREV_BUILD_ID"
            # After waiting, loop will re-evaluate PREV_RUNNING
          fi
        done
  # ==========================================
  # Step 1: Generate version tag
  # ==========================================
  - name: gcr.io/cloud-builders/gcloud
    id: generate-version
    entrypoint: bash
    args:
      - -c
      - |
        VERSION_TAG="v-$(date +%Y%m%d-%H%M%S)"
        echo "VERSION_TAG=$$VERSION_TAG" > /workspace/version.env
        echo "Generated version: $$VERSION_TAG"

  # ==========================================
  # Step 2: Build APIs and create ZIPs
  # ==========================================
  - name: gcr.io/cloud-builders/git
    id: clone-repo
    args:
      - clone
      - https://github.com/${_GITHUB_REPO}.git
      - /workspace/app

  - name: 'python:3.11'
    id: build-apis
    entrypoint: bash
    args:
      - -c
      - |
        source /workspace/version.env
        cd /workspace/app

        # Assume each API is in a folder api1, api2, ...
        for API in */; do
          API_NAME=$${API%/}
          echo "[BUILD] Processing $$API_NAME..."
          cd "$$API_NAME"

          # Create ZIP of API folder
          zip -r "/workspace/$${API_NAME}-$${VERSION_TAG}.zip" *

          cd ..
        done

  # ==========================================
  # Step 3: Upload API ZIPs to GCS
  # ==========================================
  - name: gcr.io/cloud-builders/gsutil
    id: upload-zips
    entrypoint: bash
    args:
      - -c
      - |
        source /workspace/version.env
        echo "[GCS] Uploading API ZIPs..."
        for ZIP_FILE in /workspace/*-$${VERSION_TAG}.zip; do
          API_NAME=$$(basename "$$ZIP_FILE" | cut -d'-' -f1)
          gsutil cp "$$ZIP_FILE" gs://$_GCS_BUCKET/$$API_NAME/$${VERSION_TAG}.zip
          echo "[GCS] Uploaded $$ZIP_FILE to gs://$_GCS_BUCKET/$$API_NAME/"
        done

  # ==========================================
  # Step 4: Update api_state.json in GCS
  # ==========================================
  - name: gcr.io/cloud-builders/gsutil
    id: update-json
    entrypoint: bash
    args:
      - -c
      - |
        source /workspace/version.env
        TMP_JSON=/workspace/api_state.json
        echo "{}" > $$TMP_JSON

        for API_ZIP in /workspace/*-$${VERSION_TAG}.zip; do
          API_NAME=$$(basename "$$API_ZIP" | cut -d'-' -f1)
          # Update JSON with latest version for each API
          jq --arg api "$$API_NAME" --arg version "$$VERSION_TAG" '.[$$api]=$$version' $$TMP_JSON > tmp.$$.json
          mv tmp.$$.json $$TMP_JSON
        done

        # Upload updated JSON to GCS
        gsutil cp $$TMP_JSON gs://$_GCS_BUCKET/api_state.json
        echo "[GCS] Updated api_state.json with latest versions"

timeout: 3600s
options:
  logging: CLOUD_LOGGING_ONLY
substitutions:
  _GITHUB_REPO: "20481A04K2/repo22"
  _TRIGGER_NAME: "trigger-1"
  _GCS_BUCKET: "inosuke-wasi-wasi"

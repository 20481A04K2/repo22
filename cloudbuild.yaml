steps:
  # ==========================================
  # Step 0: Wait for previous builds
  # ==========================================
  - name: gcr.io/google.com/cloudsdktool/cloud-sdk
    entrypoint: bash
    args:
      - '-c'
      - |
        echo "Checking actively running triggers..."
        WATCHED_TRIGGERS=("trigger-1" "trigger-3")
        CURRENT_TRIGGER="$${_TRIGGER_NAME:-trigger-2}"

        # Get all running/queued builds for current trigger, sorted by createTime
        SAME_TRIGGER_BUILDS=$$(gcloud builds list --region=asia-east1 \
          --filter="status:(WORKING OR QUEUED) AND substitutions._TRIGGER_NAME=$$CURRENT_TRIGGER" \
          --sort-by="createTime" \
          --format="value(id,createTime)")

        # Convert to array
        mapfile -t BUILDS_ARRAY <<< "$$SAME_TRIGGER_BUILDS"

        # Remove the latest build (assume it’s the current build itself)
        if [ $${#BUILDS_ARRAY[@]} -gt 0 ]; then
          unset 'BUILDS_ARRAY[-1]'
        fi

        wait_for_build() {
          local BUILD_ID=$$1
          local TRIGGER_NAME=$$2
          while true; do
            STATUS=$$(gcloud builds describe $$BUILD_ID --region=asia-east1 --format="value(status)")
            if [[ "$$STATUS" == "SUCCESS" || "$$STATUS" == "FAILURE" || "$$STATUS" == "CANCELLED" ]]; then
              echo "$$TRIGGER_NAME build $$BUILD_ID finished with $$STATUS"
              break
            fi
            echo "$$TRIGGER_NAME build $$BUILD_ID still running, waiting 15s..."
            sleep 15
          done
        }

        # Wait for previous builds of the same trigger
        for BUILD_INFO in "$${BUILDS_ARRAY[@]}"; do
          BUILD_ID=$$(echo $$BUILD_INFO | awk '{print $$1}')
          BUILD_START=$$(echo $$BUILD_INFO | awk '{print $$2}')
          echo "⏳ Waiting for earlier build $$BUILD_ID of $$CURRENT_TRIGGER started at $$BUILD_START..."
          wait_for_build $$BUILD_ID $$CURRENT_TRIGGER
        done


        echo "✅ All earlier builds completed → proceeding with current trigger $$CURRENT_TRIGGER"





  # ==========================================
  # Step 1: Generate version tag
  # ==========================================
  - name: gcr.io/cloud-builders/gcloud
    id: generate-version
    entrypoint: bash
    args:
      - -c
      - |
        VERSION_TAG="v-$(date +%Y%m%d-%H%M%S)"
        echo "VERSION_TAG=$$VERSION_TAG" > /workspace/version.env
        echo "Generated version: $$VERSION_TAG"

  # ==========================================
  # Step 2: Clone GitHub repo
  # ==========================================
  - name: gcr.io/cloud-builders/git
    id: clone-repo
    args:
      - clone
      - https://github.com/${_GITHUB_REPO}.git
      - /workspace/app

  # ==========================================
  # Step 3: Build the specified API and create ZIP
  # ==========================================
  - name: 'python:3.11'
    id: build-api
    entrypoint: bash
    args:
      - -c
      - |
        apt-get update && apt-get install -y zip
        source /workspace/version.env
        cd /workspace/app/${_API_NAME}

        echo "[BUILD] Processing ${_API_NAME}..."

        # Create ZIP of API folder
        zip -r "/workspace/${_API_NAME}-$${VERSION_TAG}.zip" *

  # ==========================================
  # Step 4: Upload API ZIP to GCS
  # ==========================================
  - name: gcr.io/cloud-builders/gsutil
    id: upload-zip
    entrypoint: bash
    args:
      - -c
      - |
        source /workspace/version.env
        echo "[GCS] Uploading ${_API_NAME} ZIP..."
        gsutil cp "/workspace/${_API_NAME}-$${VERSION_TAG}.zip" gs://$_GCS_BUCKET/${_API_NAME}/$${VERSION_TAG}.zip
        sleep 600
        echo "[GCS] Uploaded /workspace/${_API_NAME}-$${VERSION_TAG}.zip to gs://$_GCS_BUCKET/${_API_NAME}/"

  # ==========================================
  # Step 5: Update api_state.json in GCS
  # ==========================================
  - name: gcr.io/cloud-builders/gsutil
    id: update-json
    entrypoint: bash
    args:
      - -c
      - |
        # Install jq
        apt-get update && apt-get install -y jq

        # Load version tag
        source /workspace/version.env

        TMP_JSON="api_state.json"

        # Fetch existing JSON from GCS or create empty
        if ! gsutil cp gs://$_GCS_BUCKET/api_state.json "$$TMP_JSON" 2>/dev/null; then
          echo "{}" > "$$TMP_JSON"
        fi

        echo "Version tag: $$VERSION_TAG"
        echo "Workspace content:"
        ls -l /workspace/

        ZIP_FILE="/workspace/${_API_NAME}-$$VERSION_TAG.zip"

        # Update JSON for the built API only
        if [ -f "$$ZIP_FILE" ]; then
          echo "Updating ${_API_NAME} with version $$VERSION_TAG"
          jq --arg api "${_API_NAME}" --arg version "$$VERSION_TAG" '.[$api]=$version' "$$TMP_JSON" > tmp.json
          mv tmp.json "$$TMP_JSON"
          echo "Updated JSON file: $$TMP_JSON"
        else
          echo "No ZIP found for ${_API_NAME}, skipping JSON update."
        fi

        # Upload updated JSON back to GCS
        gsutil cp "$$TMP_JSON" gs://$_GCS_BUCKET/api_state.json
        echo "[GCS] Updated api_state.json with latest API versions"

  # ==========================================
  # Step 6: Display JSON content for verification
  # ==========================================
  - name: gcr.io/cloud-builders/gsutil
    id: show-json
    entrypoint: bash
    args:
      - -c
      - |
        echo "Current api_state.json content:"
        gsutil cp gs://$_GCS_BUCKET/api_state.json ./api_state.json
        if command -v jq >/dev/null 2>&1; then
          jq . ./api_state.json || cat ./api_state.json
        else
          cat ./api_state.json
        fi

timeout: 3600s
options:
  logging: CLOUD_LOGGING_ONLY
substitutions:
  _GITHUB_REPO: "20481A04K2/repo22"
  _TRIGGER_NAME: "trigger-2"
  _GCS_BUCKET: "inosuke-wasi-wasi"
  _API_NAME: "api2"
        
